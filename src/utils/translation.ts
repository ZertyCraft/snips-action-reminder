import { i18nFactory } from '../factories/i18nFactory'
import { Reminder } from '../class/Reminder';
import { beautify } from '.';

function getRandom(key: string | string[], opts: {[key: string]: any} = {}): string {
    const i18n = i18nFactory.get()
    const possibleValues = i18n(key, { returnObjects: true, ...opts })
    if(typeof possibleValues === 'string')
        return possibleValues
    const randomIndex = Math.floor(Math.random() * possibleValues.length)
    return possibleValues[randomIndex]
}

async function getError(error: Error) {
    let i18n = i18nFactory.get()

        if(!i18n) {
            await i18nFactory.init()
            i18n = i18nFactory.get()
        }

        if(i18n) {
            return getRandom(`error.${error.message}`)
        } else {
            return 'Oops, something went wrong.'
        }
}

/**
 * Return a report tts for found reminders
 * Example:
 *     I found 8 {{ adj }} reminders.
 *     I found 8 {{ adj }} reminders set for {{ time }}, the next one is {{ reminder }} set for {{ time }}.
 *     I found 8 {{ adj }} reminders set for {{ time }}, {{ reminder }} is set for {{ time }}.
 *     I found 8 {{ adj }} reminders named {{ reminder }}, the next one is set for {{ time }}.
 *     I found 8 {{ adj }} reminders named {{ reminder }}, {{ reminder }} is set for {{ time }}.
 * 
 * Time can be generated by "datetimeRange" slots value and "recurrence" 
 * Example:
 *     every monday at 8 AM
 *     every day at 2 50 PM
 *     3th of May at 8 PM
 *     today at 4 AM
 *     this weeekend at 5 20 PM
 *     next Friday at 3 PM
 * 
 * @param reminders 
 */
function reportGetReminder(reminders: Reminder[], isPast: boolean){
    let message = ''
    for (let i = 0; i < reminders.length; i++) {
        const reminder = reminders[i]
        if (!reminder.nextExecution) {
            throw new Error('invalideExecutionTime')
        }
        message += translation.getRandom('getReminder.info.reminder_SetFor_', {
            name: reminder.name,
            time: beautify.datetime(reminder.nextExecution)
        })
    }
    return message
}

function reportSetReminder(reminder: Reminder) {
    if (!reminder.nextExecution) {
        throw new Error('invalideExecutionTime')
    }
    return getRandom('setReminder.info.reminder_SetFor_', {
        name: reminder.name,
        time: reminder.rawRecurrence ? 
              beautify.recurrence(reminder.nextExecution, reminder.rawRecurrence) : 
              beautify.datetime(reminder.nextExecution)
    })
}

export const translation = {
    getError,
    getRandom,
    reportSetReminder,
    reportGetReminder
}